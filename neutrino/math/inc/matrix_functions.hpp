#ifndef FRAMEWORK_MATH_DETAILS
    #error You should include math/math.hpp instead of matrix_functions.hpp
#endif

#ifndef FRAMEWORK_MATH_INC_MATRIX_FUNCTIONS_HPP
    #define FRAMEWORK_MATH_INC_MATRIX_FUNCTIONS_HPP

    #include <math/inc/matrix_functions_details.hpp>
    #include <math/inc/matrix_type.hpp>

namespace framework::math
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @addtogroup math_matrix_functions
/// @{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @name transpose
/// @{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// @brief Calculate the transpose of a Matrix.
///
/// @param value Specifies the Matrix of which to take the transpose.
///
/// @return The transpose of the Matrix.
template <std::size_t C, std::size_t R, typename T>
inline Matrix<R, C, T> transpose(const Matrix<C, R, T>& value)
{
    return matrix_functions_details::transpose(value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @name component_wise_multiplication
/// @{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// @brief Perform a component-wise multiplication of two matrices.
///
/// @param lhs Specifies the first Matrix multiplicand.
/// @param rhs Specifies the second Matrix multiplicand.
///
/// @return The component-wise multiplication of two matrices.
template <std::size_t C, std::size_t R, typename T>
inline Matrix<C, R, T> component_wise_multiplication(const Matrix<C, R, T>& lhs, const Matrix<C, R, T>& rhs)
{
    Matrix<C, R, T> temp{lhs};

    for (std::size_t i = 0; i < C; ++i) {
        temp[i] *= rhs[i];
    }

    return temp;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @name outer_product
/// @{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// @brief Calculate the outer product of a pair of vectors.
///
/// @param lhs Specifies the parameter to be treated as a column vector.
/// @param rhs Specifies the parameter to be treated as a row vector.
///
/// @return The outer product of a pair of vectors.
template <std::size_t C, std::size_t R, typename T>
inline Matrix<C, R, T> outer_product(const Vector<R, T>& lhs, const Vector<C, T>& rhs)
{
    return matrix_functions_details::outer_product(lhs, rhs);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @name determinant
/// @{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// @brief Calculate the determinant of a Matrix.
///
/// @param value Specifies the Matrix of which to take the determinant.
///
/// @return The determinant of the Matrix.
template <std::size_t C, std::size_t R, typename T>
inline T determinant(const Matrix<C, R, T>& value)
{
    return matrix_functions_details::determinant(value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @name inverse
/// @{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// @brief Calculate the inverse of a Matrix.
///
/// The values in the returned Matrix are undefined if Matrix is singular or
/// poorly-conditioned (nearly singular).
///
/// @param value Specifies the Matrix of which to take the inverse.
///
/// @return The inverse of a Matrix.
template <std::size_t C, std::size_t R, typename T>
inline Matrix<C, R, T> inverse(const Matrix<C, R, T>& value)
{
    return matrix_functions_details::inverse(value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @name affine_inverse
/// @{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// @brief Calculate the inverse of a affine Matrix.
///
/// The values in the returned Matrix are undefined if Matrix contains not
/// affine transformations, or Matrix is singular or
/// poorly-conditioned (nearly singular).
///
/// @param value Specifies the Matrix of which to take the inverse.
///
/// @return The inverse of a Matrix.
template <std::size_t C, std::size_t R, typename T>
inline Matrix<C, R, T> affine_inverse(const Matrix<C, R, T>& value)
{
    return matrix_functions_details::affine_inverse(value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @name inverse_transpose
/// @{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/// @brief Calculate the inverse-transpose of a Matrix.
///
/// The values in the returned Matrix are undefined if Matrix is singular
/// or poorly-conditioned (nearly singular).
///
/// @param value Specifies the Matrix of which to take the inverse.
///
/// @return The Matrix which is equivalent to `transpose(inverse(Matrix))`.
template <std::size_t C, std::size_t R, typename T>
inline Matrix<C, R, T> inverse_transpose(const Matrix<C, R, T>& value)
{
    return matrix_functions_details::inverse_transpose(value);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// @}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

} // namespace framework::math

#endif
